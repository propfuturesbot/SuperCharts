          volume: update.volume
        };
      } else if (currentChartType === 'renko') {
        // Handle Renko brick updates
        try {
          const newBricks = updateRenkoWithNewBar(update, currentBrickSize);
          
          if (newBricks.length > 0) {
            // New Renko bricks were created
            isNewRenkoBrick = true;
            
            // Add new bricks to the chart
            newBricks.forEach(brick => {
              try {
                candleSeries.update(brick);
                renkoData.push(brick);
              } catch (brickError) {
                console.error('Error updating individual Renko brick:', brickError, brick);
              }
            });
            
            console.log(`Added ${newBricks.length} new Renko brick(s)`);
          }
          
          // Don't update with regular displayUpdate for Renko
          displayUpdate = null;
--
      volume: currentBarData.volume
    };
  } else if (currentChartType === 'renko') {
    // Handle Renko for tick data
    try {
      const newBricks = updateRenkoWithNewBar(currentBarData, currentBrickSize);
      
      if (newBricks.length > 0) {
        // Add new bricks to the chart
        newBricks.forEach(brick => {
          try {
            candleSeries.update(brick);
            renkoData.push(brick);
          } catch (brickError) {
            console.error('Error updating tick Renko brick:', brickError, brick);
          }
        });
        
        console.log(`Tick chart: Added ${newBricks.length} new Renko brick(s)`);
        return; // Don't update with regular currentBarData
      }
      
      // If no new Renko bricks, don't update the chart
      return;
    } catch (renkoError) {
      console.error('Error processing tick Renko update:', renkoError);
--
        // Store the valid data
        historicalData = validData;
        
        // Calculate Heiken Ashi data if that chart type is selected
        if (currentChartType === 'heikenashi') {
          heikenAshiData = calculateHeikenAshi(validData);
          console.log('Calculated Heiken Ashi data with', heikenAshiData.length, 'bars');
        } else if (currentChartType === 'renko') {
          renkoData = convertToRenko(validData, currentBrickSize, false);
          console.log('Calculated Renko data with', renkoData.length, 'bricks');
        }
        
        // Determine which data to display
        let dataToDisplay = validData;
        if (currentChartType === 'heikenashi') {
          dataToDisplay = heikenAshiData;
        } else if (currentChartType === 'renko') {
          dataToDisplay = renkoData;
        }
        
        // Debug: Show sample of data being set
        console.log('Sample data being set on chart:');
        console.log('First 3 bars:', JSON.stringify(dataToDisplay.slice(0, 3), null, 2));
        console.log('Last 3 bars:', JSON.stringify(dataToDisplay.slice(-3), null, 2));
        console.log('Time range:', {
          first: new Date(dataToDisplay[0].time * 1000).toLocaleString(),
          last: new Date(dataToDisplay[dataToDisplay.length - 1].time * 1000).toLocaleString(),
          totalBars: dataToDisplay.length
        });
--
        // Store the valid data
        historicalData = validData;
        
        // Calculate Heiken Ashi data if that chart type is selected
        if (currentChartType === 'heikenashi') {
          heikenAshiData = calculateHeikenAshi(validData);
        } else if (currentChartType === 'renko') {
          renkoData = convertToRenko(validData, currentBrickSize, false);
        }
        
        // Determine which data to display
        let dataToDisplay = validData;
        if (currentChartType === 'heikenashi') {
          dataToDisplay = heikenAshiData;
        } else if (currentChartType === 'renko') {
          dataToDisplay = renkoData;
        }
        
        candleSeries.setData(dataToDisplay);
        
        chart.timeScale().fitContent();
      } catch (chartError) {
        console.error('Error setting initial chart data:', chartError);
      }
    }
  } else {
    console.warn('No initial data loaded');
    updateStatus('No data available', false);
--
  console.log('Setting up real-time connection...');
  await setupRealTimeConnection();
};

// Indicator calculation functions
const calculateIndicator = (type, data, period = 14) => {
  if (!data || data.length === 0) return [];
  
  // Wait for indicators to be loaded
  if (!window.indicators) {
    console.warn('Indicators not loaded yet');
    return [];
  }
  
  const closePrices = data.map(bar => bar.close);
  const highPrices = data.map(bar => bar.high);
  const lowPrices = data.map(bar => bar.low);
  const openPrices = data.map(bar => bar.open);
  
  try {
    switch (type) {
      case 'SMA':
        return window.indicators.sma(closePrices, { period });
      case 'EMA':
        return window.indicators.ema(closePrices, { period });
      case 'RSI':
--
  }
  
  const periodNum = parseInt(period) || 14;
  
  try {
    const indicatorValues = calculateIndicator(indicatorType, historicalData, periodNum);
    
    if (!indicatorValues || indicatorValues.length === 0) {
      alert('Failed to calculate indicator values');
      document.getElementById('indicators').value = '';
      return;
    }
    
    displayIndicator(indicatorType, indicatorValues, periodNum);
    activeIndicators.set(indicatorType, { period: periodNum, values: indicatorValues });
    
    // Update the active indicators display
    updateActiveIndicatorsDisplay();
    
    // If Donchian Channel was added, display signals
    if (indicatorType === 'DonchianChannel') {
      displaySignalsOnChart();
    }
    
    console.log(`${indicatorType} indicator added successfully`);
  } catch (error) {
--
  }
  
  // Recalculate and update all active indicators
  activeIndicators.forEach((config, type) => {
    try {
      const newValues = calculateIndicator(type, historicalData, config.period);
      if (newValues && newValues.length > 0) {
        
        // Update the series data
        if ((type === 'BollingerBands' || type === 'DonchianChannel') && newValues.upper) {
          const upperSeries = indicatorSeries.get(`${type}_upper`);
          const middleSeries = indicatorSeries.get(`${type}_middle`);
          const lowerSeries = indicatorSeries.get(`${type}_lower`);
          
          if (upperSeries && middleSeries && lowerSeries) {
            const latestIndex = newValues.upper.length - 1;
            const latestTime = historicalData[historicalData.length - 1]?.time;
            
            if (latestTime) {
              upperSeries.update({ time: latestTime, value: newValues.upper[latestIndex] });
              middleSeries.update({ time: latestTime, value: newValues.middle[latestIndex] });
              lowerSeries.update({ time: latestTime, value: newValues.lower[latestIndex] });
            }
          }
        } else if (Array.isArray(newValues)) {
          const series = indicatorSeries.get(type);
--
    lastTouchUpper = false;
  }
};

// ATR calculation for Renko
const calculateATR = (data, period = 14) => {
  if (!data || data.length < period) return 50; // Default to 50 if can't calculate
  
  const trueRanges = [];
  
  for (let i = 1; i < data.length; i++) {
    const current = data[i];
    const previous = data[i - 1];
    
    const highLow = current.high - current.low;
    const highClose = Math.abs(current.high - previous.close);
    const lowClose = Math.abs(current.low - previous.close);
    
    const trueRange = Math.max(highLow, Math.max(highClose, lowClose));
    trueRanges.push(trueRange);
  }
  
  // Calculate Simple Moving Average of True Range
  if (trueRanges.length < period) return 50;
  
  let sum = 0;
--
  
  return sum / period;
};

// Renko brick calculation functions
const convertToRenko = (data, brickSize = null, useATR = true) => {
  if (!data || data.length === 0) return [];
  
  // Calculate brick size using ATR if not provided
  if (brickSize === null || useATR) {
    const atrValue = calculateATR(data);
    brickSize = Math.max(1, Math.round(atrValue * 0.5));
    console.log('Calculated ATR brick size:', brickSize);
  }
  
  // Ensure brick size is valid
  if (!brickSize || brickSize <= 0 || isNaN(brickSize)) {
    brickSize = 10; // Default fallback
  }
  
  const renkoBricks = [];
  let brickIndex = 0; // Counter for unique timestamps
  
  // Initialize with first candle
  const firstPrice = data[0].close;
  const firstTime = data[0].time;
  
  let lastBrickHigh = firstPrice;
  let lastBrickLow = firstPrice;
  let direction = 1; // 1 for up, -1 for down
  
--
  
  console.log(`Generated ${validBricks.length} valid Renko bricks with size ${brickSize}`);
  return validBricks;
};

const updateRenkoWithNewBar = (newBar, brickSize) => {
  if (!newBar || !renkoState.lastBrickHigh || !renkoState.lastBrickLow || !brickSize || brickSize <= 0) {
    return [];
  }
  
  const price = newBar.close;
  const baseTime = newBar.time;
  const newBricks = [];
  
  // Validate price
  if (!price || isNaN(price)) return [];
  
  let lastBrickHigh = renkoState.lastBrickHigh;
  let lastBrickLow = renkoState.lastBrickLow;
  
  // Start timestamp calculation from the last known timestamp
  let nextTimestamp = renkoState.lastTimestamp ? Math.max(renkoState.lastTimestamp + 1, baseTime) : baseTime;
  
  // Check for upward movement
  while (price >= lastBrickHigh + brickSize) {
    // Create green (up) brick
--
  console.log(`Real-time: Generated ${validBricks.length} new Renko bricks, last timestamp: ${renkoState.lastTimestamp}`);
  return validBricks;
};

// Heiken Ashi calculation functions
const calculateHeikenAshi = (data) => {
  if (!data || data.length === 0) return [];
  
  const haData = [];
  let prevHACandle = null;
  
  for (let i = 0; i < data.length; i++) {
    const candle = data[i];
    let haCandle = {};
    
    // Calculate Heiken Ashi values
    // HA-Close = (Open + High + Low + Close) / 4
    haCandle.close = (candle.open + candle.high + candle.low + candle.close) / 4;
    
    // For the first candle
    if (i === 0 || !prevHACandle) {
      // HA-Open = (Open + Close) / 2
      haCandle.open = (candle.open + candle.close) / 2;
    } else {
      // HA-Open = (Previous HA-Open + Previous HA-Close) / 2
      haCandle.open = (prevHACandle.open + prevHACandle.close) / 2;
--
  try {
    let dataToDisplay = historicalData;
    
    if (currentChartType === 'heikenashi') {
      // Calculate Heiken Ashi data
      heikenAshiData = calculateHeikenAshi(historicalData);
      dataToDisplay = heikenAshiData;
      console.log('Displaying Heiken Ashi data with', dataToDisplay.length, 'bars');
    } else if (currentChartType === 'renko') {
      // Calculate Renko data
      renkoData = convertToRenko(historicalData, currentBrickSize, false);
      dataToDisplay = renkoData;
      console.log('Displaying Renko data with', dataToDisplay.length, 'bricks');
      
      // Validate Renko data
      if (dataToDisplay.length === 0) {
        console.warn('No Renko bricks generated. Check brick size and data.');
        updateStatus('No Renko bricks generated', false);
        return;
      }
    } else {
      console.log('Displaying Candlestick data with', dataToDisplay.length, 'bars');
    }
    
    // Validate data before setting
    if (!dataToDisplay || dataToDisplay.length === 0) {
      console.warn('No data to display on chart');
      return;
    }
    
    // Update the chart with the appropriate data
--
    clearAllIndicators();
    
    tempIndicators.forEach((config, type) => {
      // Always use original data for indicators, not Renko or HA data
      const dataToUse = historicalData;
      const indicatorValues = calculateIndicator(type, dataToUse, config.period);
      if (indicatorValues && indicatorValues.length > 0) {
        displayIndicator(type, indicatorValues, config.period);
        activeIndicators.set(type, { period: config.period, values: indicatorValues });
      }
    });
    
    updateActiveIndicatorsDisplay();
  }
};

const updateRenkoBrickSize = () => {
  try {
    const brickSizeInput = document.getElementById('brickSizeInput');
    const newBrickSize = parseFloat(brickSizeInput.value);
    
    if (isNaN(newBrickSize) || newBrickSize <= 0) {
      alert('Please enter a valid brick size greater than 0');
      brickSizeInput.value = currentBrickSize; // Reset to current value
      return;
    }
